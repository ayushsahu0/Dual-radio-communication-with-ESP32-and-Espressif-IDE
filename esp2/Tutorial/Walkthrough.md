## ESP2 Tutorial 

This tutorial will guide you through understanding a basic ESP-IDF application for initializing GATT  and UDP (User Datagram Protocol) functionalities while handling a boot button press. This example will help you get started with GPIO configuration, BLE and UDP setup, and FreeRTOS task creation.
![FlowChart of the Dual-radio-communication-with-ESP32-and-Espressif-IDE](https://github.com/ayushsahu0/Dual-radio-communication-with-ESP32-and-Espressif-IDE/blob/main/esp2/Tutorial/ESP2.png)


## Introduction

In this example, we'll demonstrate how to set up an ESP32 project that involves:

1.  **GPIO Configuration**: To handle a boot button press.
2.  **BLE Initialization**: To set up Bluetooth Low Energy.
3.  **UDP Initialization**: To configure a UDP client.
4.  **FreeRTOS Tasks**: To handle asynchronous operations.

## Overview

This application performs the following tasks:

1.  Waits for a button press connected to GPIO 0 to start.
2.  Initializes BLE (Bluetooth Low Energy) functionality.
3.  Initializes UDP (User Datagram Protocol) communication.
4.  Starts a FreeRTOS task to handle UDP client operations.

## Prerequisites

-   **ESP-IDF**: Ensure you have the ESP-IDF framework installed and set up.
-   **ESP32 Development Board**: For running the code.
-   **Basic Knowledge**: Familiarity with C programming and FreeRTOS concepts.

## Header Files Overview

### `#include <stdio.h>`
Standard input/output library for functions like  `printf`.

### `#include <stdlib.h>`
Includes standard library functions such as memory allocation.

### `#include <string.h>`
Provides string manipulation functions.

### `#include "driver/gpio.h"`
Contains functions and macros for GPIO (General Purpose Input/Output) operations.

### `#include "sdkconfig.h"`
Configuration header file generated by ESP-IDF to manage project-specific settings.

### `#include "ble.h"`
Assumed to be a custom header file for BLE functionality. You need to define this file and include BLE initialization functions.

### `#include "wifi.h"`
Assumed to be a custom header file for Wi-Fi functionality. You need to define this file and include UDP initialization functions.

### `#include <inttypes.h>`  and  `#include <stdint.h>`
Provide fixed-width integer types for portable code.

## Constants and Global Variables


```c

#define BOOT_BUTTON_PIN GPIO_NUM_0 // Change this to the actual GPIO number connected to the boot button

#define MAX_MESSAGE_SIZE 256 // Define maximum size for received_message

  

// Global variables to store received message and its length

// Define the global variable
```
-   **Includes**: These headers include standard libraries and ESP-IDF components for GPIO, BLE, and Wi-Fi.
-   **BOOT_BUTTON_PIN**: Defines the GPIO pin number used for the boot button.
-   **MAX_MESSAGE_SIZE**: Maximum size for the message buffer.

## `Delay` Function
```c

static void delay() {
    gpio_config_t io_conf;
    io_conf.intr_type = GPIO_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pin_bit_mask = (1ULL << BOOT_BUTTON_PIN);
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pull_up_en = GPIO_PULLUP_ENABLE;
    gpio_config(&io_conf);

    printf("Waiting for boot button press...\n");

    while (gpio_get_level(BOOT_BUTTON_PIN) == 1) {
        vTaskDelay(100 / portTICK_PERIOD_MS); // Delay for 100 milliseconds
    }

    printf("Boot button pressed! Continuing with the program...\n");
    return;
}
```

-   **GPIO Configuration**: Initializes the GPIO pin as an input with a pull-up resistor.
-   **Waiting for Button Press**: Loops until the button is pressed (button press logic assumes that HIGH means not pressed).

## `app_main` Function

```c
void app_main() {
    delay(); // Ensure any necessary initialization is done

    esp_err_t ble_result = ble_init();
    if (ble_result == ESP_OK) {
        ESP_LOGI(TAG, "BLE initialization successful.");

        esp_err_t udp_result = udp_init_();
        if (udp_result == ESP_OK) {
            ESP_LOGI(TAG, "UDP initialization successful.");

            if (xTaskCreate(udp_client_task, "udp_client_task", 4096 / sizeof(StackType_t), NULL, 5, NULL) != pdPASS) {
                ESP_LOGE(TAG, "Failed to create UDP server task.");
            } else {
                ESP_LOGI(TAG, "UDP server task started.");
            }
        } else {
            ESP_LOGE(TAG, "UDP initialization failed.");
        }
    } else {
        ESP_LOGE(TAG, "BLE initialization failed.");
    }

    ESP_LOGI(TAG, "I am Here");
}
```
-   **Delay Function Call**: Ensures the application waits for the boot button press before proceeding.
-   **BLE Initialization**: Calls  `ble_init()`  to initialize BLE. Logs success or failure.
-   **UDP Initialization**: Calls  `udp_init_()`  to initialize UDP. Logs success or failure.
-   **FreeRTOS Task Creation**: Creates a task for handling UDP client operations. Logs success or failure.
-   **Final Log**: Logs a message indicating the completion of the setup.

## `ble_init()` Function

### 1. Initialize Non-Volatile Storage (NVS)
```C
esp_err_t ret = nvs_flash_init();
if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
}
ESP_ERROR_CHECK(ret);
```
-   **`nvs_flash_init()`**: Initializes the NVS library, which is used for storing data that persists through reboots.
-   **Error Handling**: If initialization fails due to no free pages or a new version, the NVS is erased and reinitialized.
-   **`ESP_ERROR_CHECK()`**: Ensures the function completes successfully; logs an error and aborts if not.
### 2. Release Classic Bluetooth Memory
```C
ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
```
**`esp_bt_controller_mem_release()`**: Frees memory allocated for Classic Bluetooth, which is not used for BLE operations. This step is crucial to ensure memory is available for BLE.

### 3. Initialize and Enable the Bluetooth Controller
```C
esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
ret = esp_bt_controller_init(&bt_cfg);
if (ret) {
    ESP_LOGE(GATTS_TAG, "%s initialize controller failed: %s", __func__, esp_err_to_name(ret));
    return ret;
}

ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
if (ret) {
    ESP_LOGE(GATTS_TAG, "%s enable controller failed: %s", __func__, esp_err_to_name(ret));
    return ret;
}
```
-   **`esp_bt_controller_init()`**: Initializes the Bluetooth controller with default settings.
-   **`esp_bt_controller_enable(ESP_BT_MODE_BLE)`**: Enables BLE mode on the Bluetooth controller.

### 4. Initialize and Enable Bluedroid Stack
```C
ret = esp_bluedroid_init();
if (ret) {
    ESP_LOGE(GATTS_TAG, "%s init bluetooth failed: %s", __func__, esp_err_to_name(ret));
    return ret;
}
ret = esp_bluedroid_enable();
if (ret) {
    ESP_LOGE(GATTS_TAG, "%s enable bluetooth failed: %s", __func__, esp_err_to_name(ret));
    return ret;
}
```
-   **`esp_bluedroid_init()`**: Initializes the Bluedroid stack, which is the Bluetooth stack used for managing BLE communication.
-   **`esp_bluedroid_enable()`**: Enables the Bluedroid stack for operation.

### 5. Register GATT and GAP Callbacks
```C
ret = esp_ble_gatts_register_callback(gatts_event_handler);
if (ret){
    ESP_LOGE(GATTS_TAG, "gatts register error, error code = %x", ret);
    return ret;
}

ret = esp_ble_gap_register_callback(gap_event_handler);
if (ret){
    ESP_LOGE(GATTS_TAG, "gap register error, error code = %x", ret);
    return ret;
}
```
-   **`esp_ble_gatts_register_callback()`**: Registers a callback function to handle GATT events, such as read/write requests.
-   **`esp_ble_gap_register_callback()`**: Registers a callback function to handle GAP events, such as connection requests and advertising.

### 6. Register GATT Applications
```C
ret = esp_ble_gatts_app_register(PROFILE_A_APP_ID);
if (ret){
    ESP_LOGE(GATTS_TAG, "gatts app register error, error code = %x", ret);
    return ret;
}

ret = esp_ble_gatts_app_register(PROFILE_B_APP_ID);
if (ret){
    ESP_LOGE(GATTS_TAG, "gatts app register error, error code = %x", ret);
    return ret;
}
```
**`esp_ble_gatts_app_register()`**: Registers GATT applications with unique IDs. Each application ID represents a separate GATT server profile.

### 7. Set Local MTU
```C
esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500);
if (local_mtu_ret){
    ESP_LOGE(GATTS_TAG, "set local MTU failed, error code = %x", local_mtu_ret);
}
```
**`esp_ble_gatt_set_local_mtu()`**: Sets the local MTU (Maximum Transmission Unit) size. A larger MTU can increase the amount of data transmitted in each BLE packet, improving data throughput.

## GATT Profile A Event Handler 

the `gatts_profile_a_event_handler` function, which handles various events related to the GATT (Generic Attribute Profile) server in a BLE (Bluetooth Low Energy) application on the ESP32. This function processes events such as service creation, characteristic read/write operations, and connection management.

### 1. `ESP_GATTS_REG_EVT` Case 
 ```C
 case ESP_GATTS_REG_EVT:
    // Event triggered when the GATT server application is successfully registered.
    ESP_LOGI(GATTS_TAG, "REGISTER_APP_EVT, status %d, app_id %d", param->reg.status, param->reg.app_id);

    // Initialize the service ID for Profile A.
    gl_profile_tab[PROFILE_A_APP_ID].service_id.is_primary = true;
    gl_profile_tab[PROFILE_A_APP_ID].service_id.id.inst_id = 0x00;
    gl_profile_tab[PROFILE_A_APP_ID].service_id.id.uuid.len = ESP_UUID_LEN_16;
    gl_profile_tab[PROFILE_A_APP_ID].service_id.id.uuid.uuid.uuid16 = GATTS_SERVICE_UUID_TEST_A;

    // Set the device name for advertising.
    esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(TEST_DEVICE_NAME);
    if (set_dev_name_ret) {
        ESP_LOGE(GATTS_TAG, "set device name failed, error code = %x", set_dev_name_ret);
    }

#ifdef CONFIG_SET_RAW_ADV_DATA
    // If raw advertising data is configured, set it.
    esp_err_t raw_adv_ret = esp_ble_gap_config_adv_data_raw(raw_adv_data, sizeof(raw_adv_data));
    if (raw_adv_ret) {
        ESP_LOGE(GATTS_TAG, "config raw adv data failed, error code = %x ", raw_adv_ret);
    }
    adv_config_done |= adv_config_flag;

    esp_err_t raw_scan_ret = esp_ble_gap_config_scan_rsp_data_raw(raw_scan_rsp_data, sizeof(raw_scan_rsp_data));
    if (raw_scan_ret) {
        ESP_LOGE(GATTS_TAG, "config raw scan rsp data failed, error code = %x", raw_scan_ret);
    }
    adv_config_done |= scan_rsp_config_flag;
#else
    // Configure standard advertising data.
    esp_err_t ret = esp_ble_gap_config_adv_data(&adv_data);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "config adv data failed, error code = %x", ret);
    }
    adv_config_done |= adv_config_flag;

    // Configure scan response data.
    ret = esp_ble_gap_config_scan_rsp_data(&scan_rsp_data);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "config scan response data failed, error code = %x", ret);
    }
    adv_config_done |= scan_rsp_config_flag;
#endif

    // Create the GATT service.
    esp_ble_gatts_create_service(gatts_if, &gl_profile_tab[PROFILE_A_APP_ID].service_id, GATTS_NUM_HANDLE_TEST_A);
    break;
```

-   **`ESP_GATTS_REG_EVT`**: This event is triggered when the GATT server application is registered with the stack.
-   **Logging**: It logs the registration status and application ID for debugging purposes.
-   **Service Initialization**: Sets up the service ID for the GATT profile. This includes marking the service as primary and setting the UUID.
-   **Device Name**: Sets the device name to be used in advertising. Logs an error if the name setting fails.
-   **Advertising Data**: Configures advertising data. Depending on the configuration (`CONFIG_SET_RAW_ADV_DATA`), it either uses raw data or standard data.
-   **Service Creation**: Creates the GATT service using the specified service ID and handle count (`GATTS_NUM_HANDLE_TEST_A`).

### 2. `ESP_GATTS_READ_EVT` Case

```C 
case ESP_GATTS_READ_EVT: {
    // Event triggered when a read request is received from a client.
    ESP_LOGI(GATTS_TAG, "GATT_READ_EVT, conn_id %d, trans_id %" PRIu32 ", handle %d", param->read.conn_id, param->read.trans_id, param->read.handle);

    // Prepare a response for the read request.
    esp_gatt_rsp_t rsp;
    memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
    rsp.attr_value.handle = param->read.handle;
    rsp.attr_value.len = 4;
    rsp.attr_value.value[0] = 0xde;
    rsp.attr_value.value[1] = 0xed;
    rsp.attr_value.value[2] = 0xbe;
    rsp.attr_value.value[3] = 0xef;

    // Send the response back to the client.
    esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id, ESP_GATT_OK, &rsp);
    break;
}
```
-   **`ESP_GATTS_READ_EVT`**: This event is triggered when a client sends a read request for a characteristic.
-   **Logging**: Logs details of the read request including connection ID, transaction ID, and handle.
-   **Response Preparation**: Creates a response (`esp_gatt_rsp_t`) containing a predefined value.
-   **Send Response**: Sends the response back to the client using  `esp_ble_gatts_send_response`.

### 3. `ESP_GATTS_WRITE_EVT` Case

```C
case ESP_GATTS_WRITE_EVT: {
    // Event triggered when a write request is received from a client.
    ESP_LOGI(GATTS_TAG, "GATT_WRITE_EVT, conn_id %d, trans_id %" PRIu32 ", handle %d", param->write.conn_id, param->write.trans_id, param->write.handle);

    if (!param->write.is_prep) {
        // Process the received write value.
        for (int i = 0; i < param->write.len; ++i) {
            snprintf(received_message + i * 2, 3, "%02x", param->write.value[i]);
        }
        received_message[param->write.len * 2] = '\0'; // Null-terminate the string

        // Extract specific characters from the received message.
        char extracted_chars[3];
        if (strlen(received_message) >= 4) {
            extracted_chars[0] = received_message[1]; // 1st character
            extracted_chars[1] = received_message[3]; // 3rd character
            extracted_chars[2] = '\0'; // Null-terminate the output string
            strcpy(received_message, extracted_chars);
        } else if (strlen(received_message) == 2) {
            extracted_chars[0] = received_message[1]; // 1st character
            extracted_chars[1] = '\0'; // Null-terminate the output string
            strcpy(received_message, extracted_chars);
        }

        ESP_LOGI(GATTS_TAG, "Received Message (String): %s", received_message);

        // Handle the write event.
        example_write_event_env(gatts_if, &a_prepare_write_env, param);

        // Check descriptor value and send notifications/indications if needed.
        if (gl_profile_tab[PROFILE_A_APP_ID].descr_handle == param->write.handle && param->write.len == 2) {
            uint16_t descr_value = param->write.value[1] << 8 | param->write.value[0];

            if (descr_value == 0x0001) {
                // Enable notifications.
                if (a_property & ESP_GATT_CHAR_PROP_BIT_NOTIFY) {
                    ESP_LOGI(GATTS_TAG, "notify enable");
                    uint8_t notify_data[15];
                    for (int i = 0; i < sizeof(notify_data); ++i) {
                        notify_data[i] = i % 0xff;
                    }
                    esp_ble_gatts_send_indicate(gatts_if, param->write.conn_id, gl_profile_tab[PROFILE_A_APP_ID].char_handle,
                                                sizeof(notify_data), notify_data, false);
                }
            } else if (descr_value == 0x0002) {
                // Enable indications.
                if (a_property & ESP_GATT_CHAR_PROP_BIT_INDICATE) {
                    ESP_LOGI(GATTS_TAG, "indicate enable");
                    uint8_t indicate_data[15];
                    for (int i = 0; i < sizeof(indicate_data); ++i) {
                        indicate_data[i] = i % 0xff;
                    }
                    esp_ble_gatts_send_indicate(gatts_if, param->write.conn_id, gl_profile_tab[PROFILE_A_APP_ID].char_handle,
                                                sizeof(indicate_data), indicate_data, true);
                }
            } else if (descr_value == 0x0000) {
                // Disable notifications and indications.
                ESP_LOGI(GATTS_TAG, "notify/indicate disable ");
            } else {
                // Handle unknown descriptor values.
                ESP_LOGE(GATTS_TAG, "unknown descr value");
                esp_log_buffer_hex(GATTS_TAG, param->write.value, param->write.len);
            }
        }
    }
    break;
}
```
-   **`ESP_GATTS_WRITE_EVT`**: This event occurs when a write request is received from a client.
-   **Logging**: Logs details of the write request including connection ID, transaction ID, and handle.
-   **Processing Write Data**: Converts the received data into a string and extracts certain characters.
-   **Handling Descriptor**: Checks if the descriptor handle matches and processes it. It enables or disables notifications/indications based on the descriptor value.
-   **Send Notifications/Indications**: Sends notification or indication data if enabled.

### 4. `ESP_GATTS_EXEC_WRITE_EVT` Case

```C 
case ESP_GATTS_EXEC_WRITE_EVT:
    // Event triggered when a prepared write operation is executed.
    ESP_LOGI(GATTS_TAG, "ESP_GATTS_EXEC_WRITE_EVT");

    // Send a response indicating that the write was successful.
    esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, NULL);

    // Handle any additional processing for executed writes.
    example_exec_write_event_env(&a_prepare_write_env, param);
    break;
```
-   **`ESP_GATTS_EXEC_WRITE_EVT`**: This event indicates that a prepared write request has been executed.
-   **Logging**: Logs the execution of the write event.
-   **Send Response**: Sends a response indicating that the write operation was successful.
-   **Handle Executed Writes**: Calls a function to handle additional processing related to the write operation.

### 5.  `ESP_GATTS_MTU_EVT`  Case

```C 
case ESP_GATTS_MTU_EVT:
    // Event triggered when the MTU (Maximum Transmission Unit) size is updated.
    ESP_LOGI(GATTS_TAG, "ESP_GATTS_MTU_EVT, MTU %d", param->mtu.mtu);
    break;
```

-   **`ESP_GATTS_MTU_EVT`**: This event occurs when the MTU size is updated.
-   **Logging**: Logs the new MTU size for debugging purposes.

### 6. `ESP_GATTS_UNREG_EVT` Case
```C
case ESP_GATTS_UNREG_EVT:
    // Event triggered when the GATT server application is unregistered.
    // No specific action is required in this case.
    break;
```
**`ESP_GATTS_UNREG_EVT`**: This event is triggered when the GATT server application is unregistered. No additional actions are needed in this case.

### 7. `ESP_GATTS_CREATE_EVT` Case

```C
case ESP_GATTS_CREATE_EVT:
    // Event triggered when a service is created successfully.
    ESP_LOGI(GATTS_TAG, "CREATE_SERVICE_EVT, status %d, service_handle %d", param->create.status, param->create.service_handle);
    
    // Store the service handle for later use.
    gl_profile_tab[PROFILE_A_APP_ID].service_handle = param->create.service_handle;

    // Set up the characteristic UUID for the service.
    gl_profile_tab[PROFILE_A_APP_ID].char_uuid.len = ESP_UUID_LEN_16;
    gl_profile_tab[PROFILE_A_APP_ID].char_uuid.uuid.uuid16 = GATTS_CHAR_UUID_TEST_A;

    // Start the service.
    esp_ble_gatts_start_service(gl_profile_tab[PROFILE_A_APP_ID].service_handle);

    // Define the characteristic properties.
    a_property = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE | ESP_GATT_CHAR_PROP_BIT_NOTIFY;

    // Add the characteristic to the service.
    esp_err_t add_char_ret = esp_ble_gatts_add_char(gl_profile_tab[PROFILE_A_APP_ID].service_handle, &gl_profile_tab[PROFILE_A_APP_ID].char_uuid,
                                                    ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                                                    a_property,
                                                    &gatts_demo_char1_val, NULL);
    if (add_char_ret) {
        ESP_LOGE(GATTS_TAG, "add char failed, error code = %x", add_char_ret);
    }
    break;

```
-   **`ESP_GATTS_CREATE_EVT`**: This event is triggered when a service is created successfully.
-   **Logging**: Logs the status and service handle.
-   **Store Service Handle**: Stores the service handle for future reference.
-   **Characteristic Setup**: Sets up the UUID for the characteristic and starts the service.
-   **Add Characteristic**: Adds the characteristic to the service with specified properties (read, write, notify). Logs an error if adding the characteristic fails.

## `udp_init()` Function
```C
/**
 * @brief Initialize UDP client
 * This function initializes the necessary components for the UDP client.
 * @return ESP_OK on success
 */
esp_err_t udp_init_()
{
    ESP_ERROR_CHECK(nvs_flash_init()); // Initialize NVS flash for storing non-volatile data
    ESP_ERROR_CHECK(esp_netif_init()); // Initialize network interface
    ESP_ERROR_CHECK(esp_event_loop_create_default()); // Create default event loop

    ESP_ERROR_CHECK(example_connect()); // Connect to Wi-Fi

    // Log the IP address of the ESP32 device
    esp_netif_ip_info_t ip_info;
    esp_netif_t *netif = esp_netif_get_handle_from_ifkey("WIFI_STA_DEF");
    if (netif) {
        esp_netif_get_ip_info(netif, &ip_info);
        ESP_LOGI(TAG, "ESP32 IP Address: " IPSTR, IP2STR(&ip_info.ip)); // Log the IP address
    } else {
        ESP_LOGE(TAG, "Failed to get netif handle");
    }

    // Uncomment the following line to create the UDP client task
    // xTaskCreate(udp_client_task, "udp_client", 4096, NULL, 5, NULL); // Create the UDP client task

    return ESP_OK;
}

#endif // WIFI_H
```
-   **Initialization**:  `udp_init_()`  initializes the necessary components for the UDP client.
-   **NVS Flash**: Initializes non-volatile storage (NVS) to store configuration data.
-   **Network Interface**: Initializes the network interface and creates the default event loop.
-   **Wi-Fi Connection**: Connects to Wi-Fi using the  `example_connect()`  function.
-   **IP Logging**: Retrieves and logs the IP address of the ESP32 device to confirm the connection.
-   **Task Creation**: The line to create the UDP client task is commented out. Uncomment it to start the UDP client task.

## `udp_client_task()` function 
```C
/**
 * @brief UDP Client Task
 * This task handles creating a UDP socket, sending messages, and waiting for acknowledgments.
 */
static void udp_client_task()
{
    int addr_family = 0;
    int ip_protocol = 0;

#if defined(CONFIG_EXAMPLE_IPV4)
    // Configure destination address for IPv4
    struct sockaddr_in dest_addr;
    dest_addr.sin_addr.s_addr = inet_addr(HOST_IP_ADDR); // Convert IP address to binary form
    dest_addr.sin_family = AF_INET; // Address family for IPv4
    dest_addr.sin_port = htons(PORT); // Convert port number to network byte order
    addr_family = AF_INET;
    ip_protocol = IPPROTO_IP; // IP protocol for IPv4

#elif defined(CONFIG_EXAMPLE_IPV6)
    // Configure destination address for IPv6
    struct sockaddr_in6 dest_addr = { 0 };
    inet6_aton(HOST_IP_ADDR, &dest_addr.sin6_addr); // Convert IPv6 address to binary form
    dest_addr.sin6_family = AF_INET6; // Address family for IPv6
    dest_addr.sin6_port = htons(PORT); // Convert port number to network byte order
    dest_addr.sin6_scope_id = esp_netif_get_netif_impl_index(EXAMPLE_INTERFACE); // Set scope ID for IPv6
    addr_family = AF_INET6;
    ip_protocol = IPPROTO_IPV6; // IP protocol for IPv6

#elif defined(CONFIG_EXAMPLE_SOCKET_IP_INPUT_STDIN)
    // Configure destination address from standard input
    struct sockaddr_storage dest_addr = { 0 };
    ESP_ERROR_CHECK(get_addr_from_stdin(PORT, SOCK_DGRAM, &ip_protocol, &addr_family, &dest_addr));
#endif

    // Create a socket
    int sock = socket(addr_family, SOCK_DGRAM, ip_protocol);
    if (sock < 0) {
        ESP_LOGE(TAG, "Unable to create socket: errno %d", errno); // Log error if socket creation fails
        vTaskDelete(NULL); // Delete the task if socket creation fails
    }

    // Set timeout for receiving data
    struct timeval timeout;
    timeout.tv_sec = 10; // Set timeout to 10 seconds
    timeout.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof timeout);

    ESP_LOGI(TAG, "Socket created, sending to %s:%d", HOST_IP_ADDR, PORT);

    // Define the expected acknowledgment message
    const char *ACK_MSG = "Ack_msg"; // Expected acknowledgment message
    char buffer[1024]; // Buffer to hold received data

    while (1) {
        // Send the message to the destination address
        int err = sendto(sock, received_message, strlen(received_message), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
        if (err < 0) {
            ESP_LOGE(TAG, "Error occurred during sending: errno %d", errno); // Log error if sending fails
            vTaskDelay(5000 / portTICK_PERIOD_MS); // Wait before retrying
            continue;
        }

        ESP_LOGI(TAG, "Message sent: %s", received_message);

        // Wait for acknowledgment
        int recv_len = recvfrom(sock, buffer, sizeof(buffer) - 1, 0, NULL, NULL);
        if (recv_len < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // Handle the non-blocking case or timeout
                ESP_LOGW(TAG, "No acknowledgment received. Retrying...");
                vTaskDelay(5000 / portTICK_PERIOD_MS); // Wait before retrying
                continue;
            } else {
                ESP_LOGE(TAG, "recvfrom failed: errno %d", errno); // Log error if receiving fails
                break; // Exit loop on error
            }
        }

        // Null-terminate the received data
        buffer[recv_len] = 0;

        // Compare the first 7 characters of the received message with ACK_MSG
        if (strncmp(buffer, ACK_MSG, 7) == 0) {
            ESP_LOGI(TAG, "Received acknowledgment: %s", buffer);
            ESP_LOGI(TAG, "Acknowledgment received, exiting task.");

            // Clean up the socket and Wi-Fi connection
            close(sock);
            ESP_LOGI(TAG, "Disconnecting from Wi-Fi...");
            esp_wifi_disconnect(); // Disconnect from Wi-Fi
            esp_wifi_stop(); // Stop Wi-Fi driver
            ESP_LOGI(TAG, "Wi-Fi driver stopped");
            esp_wifi_deinit(); // Deinitialize Wi-Fi driver
            ESP_LOGI(TAG, "Wi-Fi driver deinitialized");

            // Clean up the task
            vTaskDelete(NULL);
        } else {
            ESP_LOGW(TAG, "Acknowledgment message is not as expected. Received: %s", buffer);
            vTaskDelay(5000 / portTICK_PERIOD_MS); // Wait before retrying
        }
    }

    // Close the socket if we exit the loop
    close(sock);
    ESP_LOGI(TAG, "Socket closed");

    // Disconnect from Wi-Fi and deinitialize the Wi-Fi driver
    ESP_LOGI(TAG, "Disconnecting from Wi-Fi...");
    esp_wifi_disconnect();
    esp_wifi_stop();
    ESP_LOGI(TAG, "Wi-Fi driver stopped");
    esp_wifi_deinit();
    ESP_LOGI(TAG, "Wi-Fi driver deinitialized");

    // Clean up the task
    vTaskDelete(NULL);
    return;
}
```
-   **Task Creation**: This function  `udp_client_task`  is responsible for the core functionality of the UDP client. It creates a UDP socket, sends messages, and waits for acknowledgments.
-   **Address Configuration**: Depending on whether IPv4 or IPv6 is used, the destination address is configured accordingly. If neither is specified, it can also get the address from stdin.
-   **Socket Creation**: The socket is created for UDP communication using the specified address family and IP protocol.
-   **Timeout Setting**: A timeout is set for receiving data to avoid indefinite blocking.
-   **Message Sending and Receiving**: The task sends the  `received_message`  to the destination address and waits for an acknowledgment. If an acknowledgment is not received within the timeout period, it retries sending the message.
-   **Acknowledgment Handling**: If the expected acknowledgment message is received, the task cleans up resources and disconnects from Wi-Fi. Otherwise, it logs a warning and retries.


